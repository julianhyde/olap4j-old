/*
// $Id: $
// This software is subject to the terms of the Common Public License
// Agreement, available at the following URL:
// http://www.opensource.org/licenses/cpl.html.
// Copyright (C) 2008-2008 Julian Hyde
// All Rights Reserved.
// You must accept the terms of that agreement to use this software.
 */
package org.olap4j.transform;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

import org.olap4j.Axis;
import org.olap4j.CellSet;
import org.olap4j.OlapConnection;
import org.olap4j.OlapStatement;
import org.olap4j.mdx.SelectNode;
import org.olap4j.mdx.parser.MdxParser;
import org.olap4j.test.TestContext;

import junit.framework.TestCase;

/**
 * Testcase for org.olap4j.transform package.
 *
 * @author etdub
 * @author jhyde
 * @version $Id: $
 * @since Jul 28, 2008
 */
public class TransformTest extends TestCase {
    final TestContext.Tester tester = TestContext.instance().getTester();
    private Connection connection = null;

    public TransformTest() {
        super();
    }

    /**
     * Simple strategy to prevent connection leaks: each test that needs a
     * connection assigns it to this field, and {@link #tearDown()} closes it
     * if it is not already closed.
     */
    protected void tearDown() throws Exception {
        // Simple strategy to prevent connection leaks
        if (connection != null
            && !connection.isClosed())
        {
            connection.close();
            connection = null;
        }
    }

    protected OlapConnection getConnection() {
        OlapConnection olapConnection = null;
        try {
            if(connection == null) {
                connection = tester.createConnection();
            }
            olapConnection =
                tester.getWrapper().unwrap(connection, OlapConnection.class);

        } catch (SQLException e) {
            e.printStackTrace();
        }

        return olapConnection;
    }

    protected OlapStatement getStatement() throws SQLException {
        Statement statement = getConnection().createStatement();
        return tester.getWrapper().unwrap(statement, OlapStatement.class);
    }

    /**
     * Asserts the functionality of a transformation
     *
     * @param initialMdx initial MDX query to be transformed
     * @param expectedMdx expected MDX query after applying transform; will
     *                    be compared against the transformed query
     * @param trans the transformation to apply to the initial query
     */
    public void assertTransformTo(String initialMdx, String expectedMdx,
            MdxQueryTransform trans) {

        OlapConnection connection = getConnection();

        MdxParser mdxParser =
            connection.getParserFactory().createMdxParser(connection);

        SelectNode before = mdxParser.parseSelect(initialMdx);
        SelectNode after = trans.apply(before);

        // we also parse the expected MDX in order to normalize it
        // (eliminate any whitespace / capitalization differences)
        // note: CallNodes are not aware of function names, and as such
        // will be compared in a case-sensitive manner
        // (i.e. [SomeMember].Children vs [SomeMember].children are not
        // equal, even if they are equivalent in MDX)
        SelectNode expected = mdxParser.parseSelect(expectedMdx);

        // TODO: consider adding .equals() method to ParseTreeNode instead
        // of comparing strings (we could ignore case when comparing
        // function names in CallNodes ...)
        assertEquals(expected.toString(), after.toString());

        try {
            tearDown();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Unit test for DrillReplaceTransform
     */
    public void testDrillReplaceTransform() {
        try{
            final String initialMdx =
                "SELECT {[Measures].[Unit Sales], " +
                "        [Measures].[Store Cost], " +
                "        [Measures].[Store Sales]} ON COLUMNS, " +
                "       {[Product].[All Products]} ON ROWS " +
                "FROM Sales " +
                "WHERE ([Time].[1997])";

            final String expectedMdx =
                "SELECT {[Measures].[Unit Sales], " +
                "        [Measures].[Store Cost], " +
                "        [Measures].[Store Sales]} ON COLUMNS, " +
                "       {[Product].[All Products].Children} ON ROWS " +
                "FROM Sales " +
                "WHERE ([Time].[1997])";

            CellSet cellSet = getStatement().executeOlapQuery(initialMdx);

            MdxQueryTransform transform =
                StandardTransformLibrary.createDrillReplaceTransform(
                        Axis.ROWS,
                        0, // position ordinal in axis
                        0, // member ordinal in position
                        cellSet);

            assertTransformTo(initialMdx, expectedMdx, transform);
        }
        catch(Throwable t) {
            t.printStackTrace();
            fail();
        }

    }

    /**
     * Unit test for RollUpLevelTransform
     */
    public void testRollUpLevelTransform() {

        try{
            final String initialMdx =
                "SELECT {[Measures].[Unit Sales], " +
                "        [Measures].[Store Cost], " +
                "        [Measures].[Store Sales]} ON COLUMNS, " +
                "       {[Product].[All Products].[Food].[Deli]} ON ROWS " +
                "FROM Sales " +
                "WHERE ([Time].[1997])";

            final String expectedMdx =
                "SELECT {[Measures].[Unit Sales], " +
                "        [Measures].[Store Cost], " +
                "        [Measures].[Store Sales]} ON COLUMNS, " +
                "       {[Product].[All Products].[Food].[Deli].Parent.Level.Members} ON ROWS " +
                "FROM Sales " +
                "WHERE ([Time].[1997])";

            CellSet cellSet = getStatement().executeOlapQuery(initialMdx);

            MdxQueryTransform transform =
                StandardTransformLibrary.createRollUpLevelTransform(
                        Axis.ROWS,
                        0, // position ordinal in axis
                        0, // member ordinal in position
                        cellSet);

            assertTransformTo(initialMdx, expectedMdx, transform);
        }
        catch(Throwable t) {
            t.printStackTrace();
            fail();
        }
    }

    /**
     * Unit test for DrillDownOnPositionTransform
     */
    // TODO: change method name once the transform works
    public void donttestDrillDownOnPositionTransform() {

        // TODO: rewrite the initial and expected MDX once this transform
        // is written.
        // Will fail for now.

        try{
            final String initialMdx =
                "SELECT {[Measures].[Unit Sales], " +
                "        [Measures].[Store Cost], " +
                "        [Measures].[Store Sales]} ON COLUMNS, " +
                "       {[Product].[All Products]} ON ROWS " +
                "FROM Sales " +
                "WHERE ([Time].[1997])";

            final String expectedMdx =
                "SELECT {[Measures].[Unit Sales], " +
                "        [Measures].[Store Cost], " +
                "        [Measures].[Store Sales]} ON COLUMNS, " +
                "       {[Product].[All Products].Children} ON ROWS " +
                "FROM Sales " +
                "WHERE ([Time].[1997])";

            CellSet cellSet = getStatement().executeOlapQuery(initialMdx);

            MdxQueryTransform transform =
                StandardTransformLibrary.createDrillDownOnPositionTransform(
                        Axis.ROWS,
                        0, // position ordinal in axis
                        0, // member ordinal in position
                        cellSet);

            assertTransformTo(initialMdx, expectedMdx, transform);
        }
        catch(Throwable t) {
            t.printStackTrace();
            fail();
        }

    }

}

// End TransformTest.java

/*
// $Id$
// This software is subject to the terms of the Eclipse Public License v1.0
// Agreement, available at the following URL:
// http://www.eclipse.org/legal/epl-v10.html.
// Copyright (C) 1999-2002 Kana Software, Inc.
// Copyright (C) 2002-2009 Julian Hyde and others.
// All Rights Reserved.
// You must accept the terms of that agreement to use this software.
*/

import java_cup.runtime.*;
import java.util.*;
import org.olap4j.OlapConnection;
import org.olap4j.Axis;
import org.olap4j.mdx.*;
import org.olap4j.mdx.parser.MdxParseException;

// Preliminaries to set up and use the scanner.
parser code {:
    // Generated from $Id$
    Scanner scanner;
    private String queryString;
    private OlapConnection mdxConnection;
    private DefaultMdxParserImpl.FunTable funTable;
    private boolean load;

    /**
      * Recursively parses an expression.
      */
    ParseTreeNode recursivelyParseExp(String s)
    {
        return new DefaultMdxParser().parseExpression(
            mdxConnection, s, false, funTable);
    }

    /**
      * Parses a string to create a {@link SelectNode}.
      */
    SelectNode parseSelect(
        OlapConnection mdxConnection,
        String queryString,
        boolean debug,
        DefaultMdxParserImpl.FunTable funTable,
        boolean load)
    {
        Symbol parse_tree = null;
        this.scanner = new StringScanner(queryString, debug);
        this.mdxConnection = mdxConnection;
        this.queryString = queryString;
        this.funTable = funTable;
        this.load = load;
        try {
            if (debug) {
                parse_tree = debug_parse();
            } else {
                parse_tree = parse();
            }
            return (SelectNode) parse_tree.value;
        } catch (Exception e) {
            throw new RuntimeException(
                "Error while parsing MDX statement '" + queryString + "'",
                e);
        } finally {
            this.scanner = null;
            this.mdxConnection = null;
            this.queryString = null;
            this.funTable = null;
        }
    }

    /**
      * Parses a string to create an expression.
      */
    ParseTreeNode parseExpression(
        OlapConnection mdxConnection,
        String queryString,
        boolean debug,
        DefaultMdxParserImpl.FunTable funTable)
    {
        Symbol parse_tree = null;
        this.scanner = new PrefixScanner(
            debug,
            new StringScanner(queryString, debug),
            new int[] {DefaultMdxParserSym._VALUE_EXPRESSION});
        this.mdxConnection = mdxConnection;
        this.queryString = queryString;
        this.funTable = funTable;
        try {
            if (debug) {
                parse_tree = debug_parse();
            } else {
                parse_tree = parse();
            }
            return (ParseTreeNode) parse_tree.value;
        } catch (Exception e) {
            throw new RuntimeException(
                "Syntax error while parsing MDX expression  '" + queryString +
                "'",
                e);
        } finally {
            this.scanner = null;
            this.mdxConnection = null;
            this.queryString = null;
            this.funTable = null;
        }
    }

    /**
      * Scanner which returns a list of pre-programmed tokens, then switches
      * to a parent scanner.
      */
    private static class PrefixScanner extends Scanner {
        private final Scanner parent;
        private final int tokens[];
        private int i;

        PrefixScanner(boolean debug, Scanner parent, int[] tokens) {
            super(debug);
            this.parent = parent;
            this.tokens = tokens;
        }

        public void init() throws java.io.IOException {
            i = 0;
            parent.init();
        }

        public Symbol next_token() throws java.io.IOException {
            if (i < tokens.length) {
                return new Symbol(tokens[i++], 0, 0, null);
            }
            return parent.next_token();
        }

        ParseRegion createRegion(int left, int right) {
            return parent.createRegion(left, right);
        }
    }

    /**
     * Creates a {@link SelectNode} object.
     * Override this function to make your kind of query.
     */
    protected SelectNode newSelect(
        ParseRegion region,
        List<ParseTreeNode> withList,
        List<AxisNode> axisList,
        IdentifierNode cubeName,
        ParseTreeNode filter,
        List<IdentifierNode> cellProps)
    {
        final AxisNode filterAxis =
            filter == null ?
                null :
                new AxisNode(
                    filter.getRegion(), false, Axis.FILTER,
                    Collections.<IdentifierNode>emptyList(), filter);
        // sort axes by ordinal
        Collections.sort(
            axisList,
            new Comparator<AxisNode>() {
                public int compare(AxisNode o1, AxisNode o2) {
                    return o1.getAxis().axisOrdinal()
                        - o2.getAxis().axisOrdinal();
                }
            });
        return new SelectNode(
            region, withList, axisList, cubeName, filterAxis, cellProps);
    }

    // Override lr_parser methods for NLS.  With this error handling scheme,
    // all errors are fatal.
    public void report_fatal_error(
        String   message,
        Object   info)
        throws java.lang.Exception
    {
        done_parsing();
        try {
            report_error(message, info);
        } catch (Throwable e) {
            throw new RuntimeException(
                "MDX parser cannot recover from previous error(s)",
                e);
        }
    }

    // override lr_parser method
    public void report_error(String message, Object info)
    {
        // "Error: %1"
        throw new RuntimeException("Error: " + message);
    }

    // override lr_parser method
    public void syntax_error(Symbol cur_token)
    {
        String s = cur_token.value.toString();
        if (cur_token.left != -1) {
            final ParseRegion region =
                scanner.createRegion(cur_token.left, cur_token.right);
            throw new MdxParseException(
                region,
                "Syntax error at " + region +
                ", token '" + s + "'");
        } else {
            throw new RuntimeException(
                "Syntax error at token '" + s + "'");
        }
    }

    public void unrecovered_syntax_error(Symbol cur_token)
        throws java.lang.Exception
    {
        report_fatal_error("Couldn't repair and continue parse", cur_token);
    }

    /**
     * Returns whether the given identifier can possibly the name of an operator
     * with property syntax.
     *
     * <p>For example, <code>isFunCall("ORDINAL")</code>
     * returns true because there is a "&lt;Level&gt;.Ordinal" property.</p>
     */
    protected boolean isFunCall(String s) {
        return funTable.isProperty(s);
    }
:};

action code {:
    ParseRegion createRegion(final int... ordinals) {
        assert ordinals.length % 2 == 0;
        return ParseRegion.sum(
            new Iterable<ParseRegion>() {
                public Iterator<ParseRegion> iterator() {
                    return new Iterator<ParseRegion>() {
                        int i = 0;
                        public boolean hasNext() {
                            return i < ordinals.length;
                        }

                        public ParseRegion next() {
                            return parser.scanner.createRegion(
                                ordinals[i++], ordinals[i++]);
                        }

                        public void remove() {
                            throw new UnsupportedOperationException();
                        }
                    };
                }
            }
        );
    }


    static <T> List<T> emptyList(List<T> list) {
        if (list == null) {
            return Collections.emptyList();
        }
        return list;
    }
:};

init with {:
    scanner.init();
:};

scan with {:
    return scanner.next_token();
:};

// Terminals (tokens returned by the scanner).
// a. Keywords.
terminal
    AND,
    AS,
    AXIS,
    CASE,
    CAST,
    CELL,
    CHAPTERS,
    COLUMNS,
    DIMENSION,
    ELSE,
    EMPTY,
    END,
    FROM,
    IN,
    IS,
    MATCHES,
    MEMBER,
    NON,
    NOT,
    NULL,
    ON,
    OR,
    PAGES,
    PROPERTIES,
    ROWS,
    SECTIONS,
    SELECT,
    SET,
    THEN,
    WHEN,
    WHERE,
    XOR,
    WITH,
    _VALUE_EXPRESSION;

// b. Symbols
terminal
    ASTERISK,                   // *
    COLON,                      // :
    COMMA,                      // ,
    CONCAT,                     // ||
    DOT,                        // .
    EQ,                         // =
    GE,                         // >=
    GT,                         // >
    LBRACE,                     // {
    LE,                         // <=
    LPAREN,                     // (
    LT,                         // <
    MINUS,                      // -
    NE,                         // <>
    PLUS,                       // +
    RBRACE,                     // }
    RPAREN,                     // )
    SOLIDUS;                    // /

// c. Typed terminals
terminal Double NUMBER;
terminal String ID;
terminal String QUOTED_ID;
terminal String AMP_QUOTED_ID;
terminal String AMP_UNQUOTED_ID;
terminal String STRING;
terminal String FORMULA_STRING;
terminal String UNKNOWN; // a token the lexer doesn't like!

// Non terminals
non terminal AxisNode
    axis_specification;
non terminal ParseTreeNode
    case_expression,
    else_clause_opt,
    expression,
    factor,
    filter_specification,
    term,
    term2,
    term3,
    term4,
    term5,
    value_expression,
    value_expression_opt,
    value_expression_primary,
    where_clause_opt;
non terminal ParseTreeNode
    select_statement,
    single_formula_specification,
    statement;
non terminal IdentifierNode
    cell_property,
    compound_id,
    cube_name,
    cube_specification,
    member_name,
    set_name;
non terminal Axis.Standard
    axis_name;
non terminal String
    comp_op,
    keyword;
non terminal IdentifierNode.Segment
    identifier,
    key_identifier,
    quoted_identifier,
    unquoted_identifier,
    amp_identifier,
    amp_quoted_identifier,
    amp_unquoted_identifier;
non terminal List
    amp_identifier_list;
non terminal WithMemberNode
    member_specification;
non terminal WithSetNode
    set_specification;
non terminal PropertyValueNode
    member_property_definition;
non terminal
    cell_opt,
    dimension_opt,
    property,
    unsigned_integer;

non terminal Boolean
    non_empty_opt;

non terminal List
    axis_specification_list,
    axis_specification_list_opt,
    cell_props,
    cell_props_opt,
    comma_member_property_def_list_opt,
    dim_props,
    dim_props_opt,
    exp_list,
    exp_list_opt,
    formula_specification,
    member_property_def_list,
    property_list,
    cell_property_list,
    when_list,
    with_formula_specification_opt;

non terminal ParseTreeNode[]
    when_clause;

non terminal Double
    axis_number;

// Start symbol
start with statement;

// ----------------------------------------------------------------------------
// Elements
//
//
// <identifier> ::= <regular_identifier> | <delimited_identifier>

quoted_identifier ::=
        QUOTED_ID:i  {:
            ParseRegion region = createRegion(ileft, iright);
            RESULT = new IdentifierNode.NameSegment(
                region, i, IdentifierNode.Quoting.QUOTED);
        :}
    ;

unquoted_identifier ::=
        ID:i {:
            ParseRegion region = createRegion(ileft, iright);
            RESULT = new IdentifierNode.NameSegment(
                region, i, IdentifierNode.Quoting.UNQUOTED);
        :}
    |   keyword:i {:
            ParseRegion region = createRegion(ileft, iright);
            RESULT = new IdentifierNode.NameSegment(
                region, i, IdentifierNode.Quoting.UNQUOTED);
        :}
    ;

// for example '&foo&[1]&bar' in '[x].&foo&[1]&bar.[y]'
key_identifier ::=
       amp_identifier_list:list {:
            RESULT = new IdentifierNode.KeySegment(list);
        :}
    ;

amp_identifier_list ::=
        amp_identifier:i {:
            RESULT = new ArrayList<IdentifierNode.NameSegment>();
            RESULT.add(i);
        :}
    |
        amp_identifier_list:list amp_identifier:i {:
            list.add(i);
            RESULT = list;
        :}
    ;

amp_identifier ::=
        amp_quoted_identifier
    |
        amp_unquoted_identifier
    ;

amp_quoted_identifier ::=
        AMP_QUOTED_ID:i {:
            ParseRegion region = createRegion(ileft, iright);
            RESULT = new IdentifierNode.NameSegment(
                region, i, IdentifierNode.Quoting.QUOTED);
        :}
    ;

amp_unquoted_identifier ::=
        AMP_UNQUOTED_ID:i {:
            ParseRegion region = createRegion(ileft, iright);
            RESULT = new IdentifierNode.NameSegment(
                region, i, IdentifierNode.Quoting.UNQUOTED);
        :}
    ;

identifier ::=
        unquoted_identifier
    |   quoted_identifier
    |   key_identifier
    ;

// a keyword (unlike a reserved word) can be converted back into an
// identifier in some contexts
keyword ::=
        DIMENSION {:
            RESULT = "Dimension";
        :}
    |   PROPERTIES {:
            RESULT = "Properties";
        :}
    ;

compound_id ::=
        identifier:i {:
            RESULT = new IdentifierNode(i);
        :}
    |   compound_id:hd DOT identifier:tl {:
            RESULT = hd.append(tl);
        :}
    ;

//
// <regular_identifier> ::= <alpha_char> [{<alpha_char> | <digit>
//                                       | <underscore>}...]
//
// <delimited_identifier> ::=
//      <start_delimiter>{<double_end_delimiter> | <nondelimit_end_symbol>}
//           [{<double_end_delimiter> | <nondelimit_end_symbol> }...]
//      <end_delimiter>
//
// <start_delimiter> ::= <open_bracket>
//
// <end_delimiter> ::= <close_bracket>
//
// <double_end_delimiter> ::= <end_delimiter> end_delimiter>
//
// <nondelimit_end_symbol> ::= !! <any_character_except_delimit_end_symbol>
//
// <cube_name> ::= [ [ [ <data_source>] <catalog_name>] [<schema_name>].]
//                 <identifier>
cube_name ::= compound_id ;
//
// <data_source> ::= <identifier>
//
// <catalog_name> ::= <identifier>
//
// <schema_name> ::= <identifier>
//
// <dim_hier> ::= [<cube_name>.]<dimension_name>
//             | [[<cube_name>.]< dimension_name>.]<hierarchy_name>
// jhyde: Need more lookahead for this to work... just use id in place of
// dim_hier.
//   dim_hier ::= id;
//
// <dimension_name> ::= <identifier>
//                    | <member>.DIMENSION
//                    | <level>.DIMENSION
//                    | <hierarchy>.DIMENSION
//
// <hierarchy_name> ::= <identifier>
//                    | < member>.HIERARCHY
//                    | <level>.HIERARCHY
//
// <level> ::= [<dim_hier>.]< identifier>
//            | <dim_hier>.LEVELS(<index>)
//            | <member>.LEVEL
//
// Note: The first production is for the case when named levels are
// supported. The second production is for the case when named levels are not
// supported.
//
//
// <member> ::= [<level>.]<identifier>
//             | <dim_hier>.<identifier>
//             | <member>.<identifier>
//             | <member_value_expression>
//
// Note: The <member>.<identifier> recognizes the fact that members may
// sometimes need to be qualified by their parent names. For example,
// "Portland" is a city in Oregon, and also in Maine. So a reference to
// Portland will be either Oregon.Portland or Maine.Portland.
//
//
// <property> ::= <mandatory_property> | <user_defined_property>
//
// <mandatory_property> ::= CATALOG_NAME
//                        | SCHEMA_NAME
//                        | CUBE_NAME
//                        | DIMENSION_UNIQUE_NAME
//                        | HIERARCHY_UNIQUE_NAME
//                        | LEVEL_UNIQUE_NAME
//                        | LEVEL_NUMBER
//                        | MEMBER_UNIQUE_NAME
//                        | MEMBER_NAME
//                        | MEMBER_TYPE
//                        | MEMBER_GUID
//                        | MEMBER_CAPTION
//                        | MEMBER_ORDINAL
//                        | CHILDREN_CARDINALITY
//                        | PARENT_LEVEL
//                        | PARENT_UNIQUE_NAME
//                        | PARENT_COUNT
//                        | DESCRIPTION
//
// <user_defined_property> ::= <dim_hier>.<identifier>
//                           | <level>.<identifier>
//                           | <member>.<identifier>
//
// Note: The three productions recognize the fact that a property can apply to
// all the members of a dimension, or all the members of a level, or just to a
// member.
//
//
// <tuple> ::= <member>
//          | (<member> [, <member>...])
//          | <tuple_value_expression>
//
// Note: Each member must be from a different dimension or from a different
// hierarchy.
//
//
// <set> ::= <member>:<member>
//
// Note: Each member must be from the same hierarchy and the same level.
//
//
//         | <set_value_expression>
//         | <open_brace>[<set>|<tuple> [, <set>|<tuple>...]]<close_brace>
//
// Note: Duplicates (if any) are always retained when specifying sets in this
// fashion.
//
//
//         | (<set>)
//
// <open_brace> ::= {
//
// <close_brace> ::= }
//
// <open_bracket> ::= [
//
// <close_bracket> ::= ]
//
// <underscore> ::= _
//
// <alpha_char> ::= a | b | c | ...| z | A | B | C | ... | Z
//
// <digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
//
// Leveling Rules for Elements
//
// The ability to qualify a cube name by one or more of <data_source>,
// <catalog_name>, or <schema_name> is optional. Consumers can check the value
// of the property MDPROP_MDX_OBJQUALIFICATION to see whether a provider
// supports cube qualification.
//
//
// The ability to qualify a dimension name by a cube name is
// optional. Consumers can check the value of the property
// MDPROP_MDX_OBJQUALIFICATION to see whether a provider supports dimension
// qualification.
//
//
// The ability to qualify a hierarchy name by a dimension name or by cube name
// and dimension name is optional. Consumers can check the value of the
// property MDPROP_MDX_OBJQUALIFICATION to see whether a provider supports
// hierarchy qualification.
//
//
// The provider need support only one of the two productions for <level>. If it
// supports
//
// <level> ::= [<dim_hier>.] <identifier>
//
// then the ability to qualify by <dim_hier> is optional.
//
// Consumers can check the value of the property MDPROP_NAMED_LEVELS to see if
// the provider supports named levels. If it does, then the consumer can check
// MDPROP_MDX_OBJQUALIFICATION to see whether named levels can be qualified by
// <dim_hier>.
//
// The ability to qualify a member by a level, a member, or <dim_hier> is
// optional. Consumers can check the value of the property
// MDPROP_MDX_OBJQUALIFICATION to see whether a provider supports member
// qualification.
//
// Note: Several leveling rules above make it optional to qualify
// multidimensional schema object names. However, this does not imply that the
// ability to generate unique names for members, levels, dimensions, and
// hierarchies is optional. Providers are required to furnish unique names in
// the schema rowsets for these objects. If providers generate unique names by
// means other than qualification, then the ability to qualify is optional. For
// more information, see 'Provider Implementation Considerations for Unique
// Names' in Chapter 2.
//
//

// ----------------------------------------------------------------------------
//
//
// Expressions
//
// Note: The syntax of <value_expression> is generally the same as SQL-92,
// subclause 6.11, <value_expression>. Differences are:
//
// <tuple>[.VALUE], <property>[.VALUE], and <conditional_expression> are new
// values for <value_expression_primary>.
//
//
// There are new values for <numeric_value_function>, mainly for statistical
// analysis.
//
//
// The BNF for <value_expression_primary>, <character_string_literal>, and
// <string_value_expression> have been shortened by eliminating several
// intermediate nonterminals.
//
// <value_expression> ::= <numeric_value_expression>
//                      | <string_value_expression>
//
// <numeric_value_expression> ::= <term>
//                    | <numeric_value_expression> {<plus> | <minus>} <term>
value_expression ::=
        term5
    |   value_expression:x OR term5:y {:
            ParseRegion region = createRegion(xleft, yright);
            RESULT = new CallNode(region, "OR", Syntax.Infix, x, y);
        :}
    |   value_expression:x XOR term5:y {:
            ParseRegion region = createRegion(xleft, yright);
            RESULT = new CallNode(region, "XOR", Syntax.Infix, x, y);
        :}
    ;

term5 ::=
        term4
    |   term5:x AND term4:y {:
            ParseRegion region = createRegion(xleft, yright);
            RESULT = new CallNode(region, "AND", Syntax.Infix, x, y);
        :}
    ;

term4 ::=
        term3
    |   NOT:not term4:p {:
            ParseRegion region = createRegion(notleft, pright);
            RESULT = new CallNode(region, "NOT", Syntax.Prefix, p);
        :}
    ;

term3 ::=
        term2
    |   term3:x comp_op:op term2:y {: // e.g. "1 < 5"
            ParseRegion region = createRegion(xleft, yright);
            RESULT = new CallNode(region, op, Syntax.Infix, x, y);
        :}
    |
        // We expect a shift-reduce conflict here, because NULL is a literal and
        // so is a valid argument to the IS operator. JavaCUP resolves the
        // conflict by shifting, which is what we want. Compile with expect=61
        // to ignore the conflicts and continue.
        term3:x IS NULL:n {:
            ParseRegion region = createRegion(xleft, nright);
            RESULT = new CallNode(region, "IS NULL", Syntax.Postfix, x);
        :}
    |   term3:x IS term2:y {: // e.g. "x IS y"; but "x IS NULL" is handled elsewhere
            ParseRegion region = createRegion(xleft, yright);
            RESULT = new CallNode(region, "IS", Syntax.Infix, x, y);
        :}
    |   term3:x IS EMPTY:empty {:
            ParseRegion region = createRegion(xleft, emptyright);
            RESULT = new CallNode(region, "IS EMPTY", Syntax.Postfix, x);
        :}
    |   term3:x MATCHES term2:y {:
            ParseRegion region = createRegion(xleft, yright);
            RESULT = new CallNode(region, "MATCHES", Syntax.Infix, x, y);
        :}
    |   term3:x NOT MATCHES term2:y {:
            ParseRegion region = createRegion(xleft, yright);
            RESULT =
                new CallNode(
                    region, "NOT", Syntax.Prefix,
                    new CallNode(region, "MATCHES", Syntax.Infix, x, y));
        :}
    |   term3:x IN term2:y {:
            ParseRegion region = createRegion(xleft, yright);
            RESULT = new CallNode(region, "IN", Syntax.Infix, x, y);
        :}
    |   term3:x NOT IN term2:y {:
            ParseRegion region = createRegion(xleft, yright);
            RESULT =
                new CallNode(
                    region, "NOT", Syntax.Prefix,
                    new CallNode(region, "IN", Syntax.Infix, x, y));
        :}
    ;

term2 ::=
        term
    |   term2:x PLUS term:y {:
            ParseRegion region = createRegion(xleft, yright);
            RESULT = new CallNode(region, "+", Syntax.Infix, x, y);
        :}
    |   term2:x MINUS term:y {:
            ParseRegion region = createRegion(xleft, yright);
            RESULT = new CallNode(region, "-", Syntax.Infix, x, y);
        :}
    |   term2:x CONCAT term:y {:
            ParseRegion region = createRegion(xleft, yright);
            RESULT = new CallNode(region, "||", Syntax.Infix, x, y);
        :}
    ;

//
// <term> ::= <factor> | <term> {<asterisk> | <solidus>} <factor>
term ::=
        factor
    |   term:x ASTERISK factor:y {:
            ParseRegion region = createRegion(xleft, yright);
            RESULT = new CallNode(region, "*", Syntax.Infix, x, y);
        :}
    |   term:x SOLIDUS factor:y {:
            ParseRegion region = createRegion(xleft, yright);
            RESULT = new CallNode(region, "/", Syntax.Infix, x, y);
        :}
    ;
//
// <factor> ::= [<sign>] <numeric_primary>
//
factor ::=
        value_expression_primary
    |   PLUS value_expression_primary:p {:
            RESULT = p;
        :}
    |   MINUS:minus value_expression_primary:p {:
            ParseRegion region = createRegion(minusleft, pright);
            RESULT = new CallNode(region, "-", Syntax.Prefix, p);
        :}
    ;

// <sign> ::= + | -
//
// <plus> ::= +
//
// <minus> ::= -
//
// <asterisk>::= *
//
// <solidus> ::= /
//
// <numeric_primary> ::= <value_expression_primary>
//                     | <numeric_value_function>
//
// Note: The data type of <value_expression_primary> in the above production
// shall be numeric.
//
//
// <value_expression_primary> ::= <unsigned_numeric_literal>
//                             | (<value_expression>)
//                             |  <character_string_literal>
//                             | [<cube_name>.]<tuple>[.VALUE]
//                             |  <property>[.VALUE]
//                             |  <conditional_expression>
value_expression_primary ::=
        STRING:s {:
            ParseRegion region = createRegion(sleft, sright);
            RESULT = LiteralNode.createString(region, s);
        :}
    |   NUMBER:d {:
            ParseRegion region = createRegion(dleft, dright);
            RESULT = LiteralNode.create(region, d);
        :}
    |   identifier:i {:
            RESULT = new IdentifierNode(i);
        :}
    |   value_expression_primary:i DOT unquoted_identifier:j {:
            if (i instanceof IdentifierNode && !parser.isFunCall(j.getName())) {
                RESULT = ((IdentifierNode) i).append(j);
            } else {
                ParseRegion region = createRegion(ileft, jright);
                RESULT = new CallNode(region, j.getName(), Syntax.Property, i);
            }
        :}
    |   value_expression_primary:i DOT quoted_identifier:j {:
            if (i instanceof IdentifierNode) {
                RESULT = ((IdentifierNode) i).append(j);
            } else {
                ParseRegion region = createRegion(ileft, jright);
                RESULT = new CallNode(
                    region, j.getName(), Syntax.QuotedProperty, i);
            }
        :}
    |   value_expression_primary:i DOT key_identifier:j {:
            if (i instanceof IdentifierNode) {
                RESULT = ((IdentifierNode) i).append(j);
            } else {
                ParseRegion region = createRegion(ileft, jright);
                RESULT = new CallNode(
                    region, j.getName(), Syntax.AmpersandQuotedProperty, i);
            }
        :}
    |   value_expression_primary:i DOT identifier:j LPAREN exp_list_opt:lis
        RPAREN:rparen {:
            lis.add(0, i);
            ParseRegion region = createRegion(ileft, rparenright);
            RESULT = new CallNode(region, j.getName(), Syntax.Method, lis);
        :}
    |   identifier:i LPAREN exp_list_opt:lis RPAREN:rparen {:
            ParseRegion region = createRegion(ileft, rparenright);
            RESULT = new CallNode(region, i.getName(), Syntax.Function, lis);
        :}
    |   CAST:cast LPAREN expression:e AS identifier:t RPAREN:rparen {:
            LiteralNode symbol =
                LiteralNode.createSymbol(t.getRegion(), t.getName());
            ParseRegion region = createRegion(castleft, rparenright);
            RESULT = new CallNode(region, "CAST", Syntax.Cast, e, symbol);
        :}
    |   LPAREN:lparen exp_list:lis RPAREN:rparen {:
            // Whereas ([Sales],[Time]) and () are tuples, ([Sales]) and (5)
            // are just expressions.
            ParseRegion region = createRegion(lparenleft, rparenright);
            RESULT = new CallNode(region, "()", Syntax.Parentheses, lis);
        :}
    |   LBRACE:lbrace exp_list_opt:lis RBRACE:rbrace {:
            // set built from sets/tuples
            ParseRegion region = createRegion(lbraceleft, rbraceright);
            RESULT = new CallNode(region, "{}", Syntax.Braces, lis);
        :}
    |  NULL:n {:
            ParseRegion region = createRegion(nleft, nright);
            RESULT = LiteralNode.createNull(region);
        :}
    |   case_expression
    ;

case_expression ::=
        CASE:kase value_expression_opt:x
        when_list:y
        else_clause_opt:z
        END {:
            List v = new ArrayList();
            if (x != null) {
                v.add(x);
            }
            for (int i = 0; i < y.size(); i++) {
                ParseTreeNode[] exps = (ParseTreeNode[]) y.get(i);
                assert exps.length == 2;
                v.add(exps[0]);
                v.add(exps[1]);
            }
            if (z != null) {
                v.add(z);
            }
            ParseRegion region = createRegion(kaseleft, zright);
            if (x == null) {
                RESULT = new CallNode(region, "_CaseTest", Syntax.Case, v);
            } else {
                RESULT = new CallNode(region, "_CaseMatch", Syntax.Case, v);
            }
        :}
    ;

value_expression_opt ::=
        /* empty */
    |   value_expression
    ;

when_list ::=
        /* empty */ {:
            RESULT = new ArrayList();
        :}
    |   when_list:x when_clause:y {:
            RESULT = x;
            x.add(y);
        :}
    ;

when_clause ::=
        WHEN value_expression:x THEN value_expression:y {:
            RESULT = new ParseTreeNode[] {x, y};
        :}
    ;

else_clause_opt ::=
        /* empty */
    |   ELSE value_expression:x {:
            RESULT = x;
        :}
    ;

//
// <conditional_expression> ::= <if_expression> | <case_expression>
//
// <if_expression> ::= iif(<search_condition>, <true_part>, <false_part>)
//
// <true_part> ::= <value_expression>
//
// <false_part> ::= <value_expression>
//
// <case_expression> ::= <simple_case> | <searched_case> | <coalesce_empty>
//
// <simple_case> ::= CASE <case_operand>
//                      <simple_when_clause>...
//                     [<else_clause>]
//                   END
//
// <searched_case> ::= CASE
//                        <searched_when_clause>...
//                       [<else_clause>]
//                     END
//
// <simple_when_clause> ::= WHEN <when_operand> THEN <result>
//
// <searched_when_clause> ::= WHEN <search_condition> THEN <result>
//
// <else_clause> ::= ELSE <value_expression>
//
// <case_operand> ::= <value_expression>
//
// <when_operand> ::= <value_expression>
//
// <result> ::= <value_expression>
//
// <coalesce_empty> ::= COALESCEEMPTY (<value_expression>
//                                  {, <value_expression> }...)
//
// <signed_numeric_literal> ::= [<sign>]<unsigned_numeric_literal>
//
// <unsigned_numeric_literal> ::= <exact_numeric_literal>
//                              | <approximate_numeric_literal>
//
// <exact_numeric_literal> ::= <unsigned_integer>[.<unsigned_integer>]
//                           | <unsigned_integer>.
//                           | .<unsigned_integer>
//
// <unsigned_integer> ::= {<digit>}...
//
// <approximate_numeric_literal> ::= <mantissa>E<exponent>
//
// <mantissa> ::= < exact_numeric_literal>
//
// <exponent> ::= [<sign>]<unsigned_integer>
//
// <string_value_expression> ::= <value_expression_primary>
//                             | <string_value_expression>
//                               <concatenation_operator>
//                               <value_expression_primary>
//
// Note: The data type of <value_expression_primary> in the above production
// shall be a character string.
//
//
// <character_string_literal> ::= <quote>[<character_representation>...]
//                               <quote>
//
// <character_representation> ::= <nonquote_character> | <quote_symbol>
//
// <nonquote_character> ::= !!
//                     <any_character_in_the_character_set_other_than_quote>
//
// <quote_symbol> ::= <quote> <quote>
//
// <quote>  ::= '
//
// <concatenation_operator> ::= ||
//
// Leveling Rules for Expressions
//
// The following productions for <value_expression_primary> are optional:
//
// The ability to qualify <tuple>[.VALUE] by <cube_name> in a value expression
// primary is optional. Consumers can check the value of the property
// MDPROP_MDX_OUTERREFERENCE to see whether a provider supports this feature.
//
//
// <property>[.VALUE]. Consumers can check the value of the property
// MDPROP_MDX_QUERYBYPROPERTY to see whether a provider supports this feature.
//
//
// <simple_case>, <searched_case>. Consumers can check the value of the
// property MDPROP_MDX_CASESUPPORT to see whether a provider supports this
// feature.
//

// ----------------------------------------------------------------------------
// Search Condition
//
// <search_condition> ::= <boolean_term>
//                      | <search_condition> {OR | XOR} <boolean_term>
//
// <boolean_term> ::= <boolean_factor> | <boolean_term> AND <boolean_factor>
//
// <boolean_factor> ::= [NOT] <boolean_primary>
//
// <boolean_primary> ::= <value_expression> <comp_op> <value_expression>
//                     | ISEMPTY(<value_expression>)
//                     | <value_expression> IS EMPTY
//                     | (<search_condition>)
// <comp_op> ::= <equals_operator>
//             | <not_equals_operator>
//             | <less_than_operator>
//             | <greater_than_operator>
//             | <less_than_or_equals_operator>
//             | <greater_than_or_equals_operator>
// "IS" is not a comp_op because of conflict with "<expr> IS EMPTY"
comp_op ::=
        EQ {:
            RESULT = "=";
        :}
    |   NE {:
            RESULT = "<>";
        :}
    |   LT {:
            RESULT = "<";
        :}
    |   GT {:
            RESULT = ">";
        :}
    |   LE {:
            RESULT = "<=";
        :}
    |   GE {:
            RESULT = ">=";
        :}
    ;
//
// <equals_operator> ::= =
//
// <not_equals_operator> ::= <>
//
// <greater_than_operator> ::= >
//
// <less_than_operator> ::= <
//
// <greater_than_or_equals_operator> ::= >=
//
// <less_than_or_equals_operator> ::= <=
//
// Leveling Rules for Search Condition
//
// If <value_expression> in a <boolean_primary> value is a string value
// expression, then support for <comp_op> values other than <equals_operator>
// and <not_equals_operator> is optional. Consumers can check the value of the
// property MDPROP_MDX_STRING_COMPOP to see whether a provider supports this
// feature.

// ----------------------------------------------------------------------------
// Set Value Expression
//
// <index> ::= <numeric_value_expression>
//
// Note: <index> denotes an integer argument. If an arbitrary
// <numeric_value_expression> appears here, then it is truncated to the nearest
// integer.
//
//
// <percentage> ::= <numeric_value_expression>
//
// <set_value_expression> ::= <dim_hier>.MEMBERS
//                          | <level>.MEMBERS
//                          | <member>.CHILDREN
//                          | BOTTOMCOUNT(<set>, <index>
//                               [, <numeric_value_expression>])
//                          | BOTTOMPERCENT(<set>, <percentage>,
//                               <numeric_value_expression>)
//                          | BOTTOMSUM(<set>, <numeric_value_expression>,
//                               <numeric_value_expression>)
//                          | CROSSJOIN(<set>, <set>)
//                          | DESCENDANTS(<member>, <level> [,<desc_flags>])
//
// Note: In the absence of explicit <desc_flags> specification, SELF is the
// default.
//
//                          | DISTINCT(<set>)
//                          | DRILLDOWNLEVEL(<set> [, <level>]])
//                          | DRILLDOWNLEVELBOTTOM(<set>, <index>
//                              [,[<level>] [, <numeric_value_expression>]])
//                          | DRILLDOWNLEVELTOP(<set>, <index>[, [<level>]
//                              [, <numeric_value_expression>]])
//                          | DRILLDOWNMEMBER(<set>, <set>[, RECURSIVE])
//                          | DRILLDOWNMEMBERBOTTOM(<set>, <set>, <index>
//                             [, <numeric_value_expression>][, RECURSIVE]])
//                          | DRILLDOWNMEMBERTOP(<set>, <set>, <index>
//                            [, [<numeric_value_expression>][, RECURSIVE]])
//                          | DRILLUPLEVEL(<set>[, <level>]])
//                          | DRILLUPMEMBER(<set>, <set>)
//                          | EXCEPT(<set>, <set> [, ALL])
//                          | EXTRACT(<set>, <dim_hier>[, <dim_hier>...])
//                          | FILTER(<set>, <search_condition>)
//                          | GENERATE(<set>, <set> [, ALL])
//                          | HIERARCHIZE(<set>)
//                          | INTERSECT(<set>, <set> [, ALL])
//                          | LASTPERIODS(<index> [, <member>])
//                          | MTD([<member>])
//                          | ORDER(<set>, <value_expression>
//                              [, ASC | DESC | BASC | BDESC])
//
// Note:   In the absence of explicit specification, ASC is the default.
//
//
//                          | PERIODSTODATE([<level>[, <member>]])
//                          | QTD([<member>])
//                          | TOGGLEDRILLSTATE(<set1>, <set2>[, RECURSIVE])
//
// Note: With the exception of CROSSJOIN, all set functions that take more than
// one <set> argument require that the two set arguments have tuples of the
// same dimensionality.
//
//
//                          | TOPCOUNT(<set>, <index>
//                              [, <numeric_value_expression>])
//                          | TOPPERCENT(<set>, <percentage>,
//                              <numeric_value_expression>)
//                          | TOPSUM(<set>, <numeric_value_expression>,
//                              <numeric_value_expression>)
//                          | UNION(<set>, <set> [, ALL])
//                          | WTD([<member>])
//                          | YTD(<member>)
//
// <desc_flags> ::= SELF
//                | AFTER
//                | BEFORE
//                | BEFORE_AND_AFTER
//                | SELF_AND_AFTER
//                | SELF_AND_BEFORE
//                | SELF_BEFORE_AFTER
//

// ----------------------------------------------------------------------------
// Member Value Expression
//
// <member_value_expression> ::= <member>.{PARENT | FIRSTCHILD | LASTCHILD
//                                         | PREVMEMBER | NEXTMEMBER}
//                             | <member>.LEAD(<index>)
//                             | <member>.LAG(<index>)
//
// Note:   LAG(<index>) is the same as LEAD(-<index>)
//
//
//                             | <member>.{FIRSTSIBLING | LASTSIBLING}
//                             | <dimension>.[CURRENTMEMBER]
//                             | <dimension>.DEFAULTMEMBER
//                             | <hierarchy>.DEFAULTMEMBER
//                             | ANCESTOR(<member>, <level>)
//                             | CLOSINGPERIOD([<level>[, <member>])
//                             | COUSIN(<member>, <member>)
//                             | OPENINGPERIOD([<level>[, <member>])
//                             | PARALLELPERIOD([<level>[, <index>
//                                              [, <member>]]])
expression ::=
        expression:x COLON value_expression:y {: // range yields set
            ParseRegion region = createRegion(xleft, yright);
            RESULT = new CallNode(region, ":", Syntax.Infix, x, y);
        :}
    |   value_expression
    ;
exp_list_opt ::=
        /* empty */ {:
            RESULT = new LinkedList();
        :}
    |   exp_list
    ;
exp_list ::=
        expression:e {:
            RESULT = new LinkedList();
            RESULT.add(e);
        :}
    |   expression:e COMMA exp_list:list {:
            list.add(0, e); RESULT = list;
        :}
    ;
//
// Leveling Rules for Member Value Expression
//
// The following member functions are optional: COUSIN, PARALLELPERIOD,
// OPENINGPERIOD, CLOSINGPERIOD. Consumers can check the value of the property
// MDPROP_MDX_MEMBER_FUNCTIONS to see whether a provider supports this feature.
//

//
//  * Tuple Value Expression
//
// <tuple_value_expression> ::= <set>.CURRENTMEMBER
//                            | <set>[.ITEM](<string_value_expression>
//                               [, <string_value_expression>...] | <index>)
//

//
//  * Numeric Value Function
//
// <numeric_value_function> ::=
//        AGGREGATE(<set> [, <numeric_value_expression>])
//      | AVG(<set>[, <numeric_value_expression>])
//      | CORRELATION(<set> [, <numeric_value_expression>]
//           [, <numeric_value_expression>])
//      | COVARIANCE(<set>[, <numeric_value_expression>
//           [, <numeric_value_expression>])
//      | COUNT(<set>[, INCLUDEEMPTY])
//      | LINREGINTERCEPT(<set>[, <numeric_value_expression>
//
//
// Leveling Rules for Numeric Value Function
//
// The following numeric functions are optional: MEDIAN, VAR, STDEV, RANK,
// AGGREGATE, COVARIANCE, CORRELATION, LINREGSLOPE, LINREGVARIANCE, LINREGR2,
// LINREGPOINT. Consumers can check the value of the property
// MDPROP_MDX_NUMERIC_FUNCTIONS to see whether a provider supports this
// feature.
//

// ----------------------------------------------------------------------------
// MDX Statement
//
// <MDX_statement> ::= <select_statement>
//                   | <create_formula_statement>
//                   | <drop_formula_statement>
//

// <select_statement> ::= [WITH <formula_specification>]
//                         SELECT [<axis_specification>
//                                [, <axis_specification>...]]
//                         FROM [<cube_specification>]
//                         WHERE [<filter_specification>]
//                         [<cell_props>]
// jhyde: The above is wrong... you can omit 'WHERE'.
statement ::=
        select_statement
    |   _VALUE_EXPRESSION value_expression:e {:
            RESULT = (ParseTreeNode) e;
        :}
    ;

select_statement ::=
        with_formula_specification_opt:f
        SELECT:select axis_specification_list_opt:a
        FROM cube_specification:c
        where_clause_opt:w
        cell_props_opt:cp {:
            ParseRegion region = createRegion(selectleft, selectright);
            RESULT = parser.newSelect(region, f, a, c, w, cp);
        :};

with_formula_specification_opt ::=
    /* empty */ {:
            RESULT = new LinkedList();
        :}
    |   WITH formula_specification:f {:
            RESULT = f;
        :}
    ;
axis_specification_list_opt ::=
        /* empty */ {:
            RESULT = new LinkedList();
        :}
    |   axis_specification_list
    ;
axis_specification_list ::=
        axis_specification:i {:
            RESULT = new LinkedList();
            RESULT.add(i);
        :}
    |   axis_specification:e COMMA axis_specification_list:list {:
            list.add(0, e);
            RESULT = list;
        :}
    ;
where_clause_opt ::=
        /* empty */
    |   WHERE filter_specification:s {:
            RESULT = s;
        :};
cell_props_opt ::=
        /* empty */ {:
            RESULT = new LinkedList();
        :}
    |   cell_props;

//
// <formula_specification> ::= <single_formula_specification>
//                            [<single_formula_specification>...]
//
formula_specification ::=
        single_formula_specification:e {:
            RESULT = new LinkedList();
            RESULT.add(e);
        :}
    |   single_formula_specification:hd formula_specification:tl {:
            tl.add(0, hd);
            RESULT = tl;
        :}
    ;

// <single_formula_specification> ::= <member_specification>
//                                  | <set_specification>
//
single_formula_specification ::=
        member_specification
    |   set_specification
    ;
//
// <member_specification> ::= MEMBER <member_name> AS <value_expression>
//                                 [, <solve_order_specification>]
//                                 [, <member_property_definition>...]
member_specification ::=
        MEMBER:member member_name:m AS FORMULA_STRING:s
        comma_member_property_def_list_opt:l {:
            ParseTreeNode e = parser.recursivelyParseExp(s);
            ParseRegion region = createRegion(memberleft, sright);
            RESULT = new WithMemberNode(region, m, e, l);
        :}
    |   MEMBER:member member_name:m AS value_expression:e
        comma_member_property_def_list_opt:l {:
            ParseRegion region = createRegion(memberleft, eright);
            RESULT = new WithMemberNode(region, m, e, l);
        :}
    ;
comma_member_property_def_list_opt ::=
        /* empty */ {:
            RESULT = new LinkedList();
        :}
    |   COMMA member_property_def_list:l {:
            RESULT = l;
        :}
    ;
member_property_def_list ::=
        member_property_definition:m {:
            RESULT = new LinkedList();
            RESULT.add(m);
        :}
    |   member_property_definition:hd COMMA member_property_def_list:tl {:
            RESULT = tl;
            RESULT.add(0, hd);
        :}
    ;
//
// <member_name> ::= <member>.<identifier>
//                 | <cube_name>.<member>.<identifier>
//
member_name ::= compound_id;
//
// Note:
//
// The identifier defines a new member. The qualification member has enough
// information to specify the dimension, and the level in the dimension that
// this new member should be on.
//
//
// If <member_name> is part of a member specification that appears in a create
// formula statement or is part of a drop formula statement, then it must be
// qualified by a cube name, as in the second production above.
//
// <solve_order_specification> ::= SOLVE_ORDER = <unsigned_integer>
//
// <member_property_definition> ::= <identifier> = <value_expression>
member_property_definition ::=
        identifier:id EQ value_expression:e {:
            ParseRegion region = createRegion(idleft, eright);
            RESULT = new PropertyValueNode(region, id.getName(), e);
        :}
    ;
//
// Note: Since the property definition appears in the context of a member
// definition, there is enough information to associate the identifier (which
// is the property name) in the above production with a member.
//
//
// <set_specification> ::= SET <set_name> AS <set>
set_specification ::=
        SET:set set_name:n AS FORMULA_STRING:s {:
            ParseTreeNode e = parser.recursivelyParseExp(s);
            ParseRegion region = createRegion(setleft, sright);
            RESULT = new WithSetNode(region, n, e);
        :}
    |   SET:set set_name:n AS expression:e {:
            ParseRegion region = createRegion(setleft, eright);
            RESULT = new WithSetNode(region, n, e);
        :}
    ;
//
// <set_name> ::= <identifier> | <cube_name>.<identifier>
set_name ::= compound_id ;
//
// Note: If <set_name> is part of a set specification that appears in a create
// formula statement or is part of a drop formula statement, then it must be
// qualified by a cube name, as in the second production above.
//
//
// <axis_specification> ::= [NON EMPTY] <set> [<dim_props>] ON <axis_name>
axis_specification ::=
        non_empty_opt:b expression:s dim_props_opt:dp ON axis_name:a {:
            ParseRegion region = createRegion(
                bleft, bright, sleft, sright, dpleft, dpright, aleft, aright);
            RESULT = new AxisNode(region, b, a, emptyList(dp), s);
        :}
    |   non_empty_opt:b expression:s dim_props_opt:dp ON axis_number:n {:
            double d = n.doubleValue();
            int index = (int)d;

            // AxisOrdinal values go from -2 to 4 for standard axis, but higher
            // ordinals are allowed. The negative values represent
            // special cases, so are ignored.
            if (index < 0 || index != d) {
                throw new MdxParseException(
                    createRegion(nleft, nright),
                    "Invalid axis specification. The axis number must be a " +
                    "non-negative integer, but it was " + d + ".");
            }

            Axis axis = Axis.Factory.forOrdinal(index);
            ParseRegion region = createRegion(
                bleft, bright, sleft, sright, dpleft, dpright, nleft, nright);
            RESULT = new AxisNode(region, b, axis, emptyList(dp), s);
        :}
    ;

non_empty_opt ::=
        /* empty */ {:
            RESULT = Boolean.FALSE;
        :}
    |   NON EMPTY {:
            RESULT = Boolean.TRUE;
        :}
    ;
dim_props_opt ::=
        /* empty */
    |   dim_props
    ;
//
// <axis_name> ::= COLUMNS
//               | ROWS
//               | PAGES
//               | CHAPTERS
//               | SECTIONS
//               | AXIS(<index>)
axis_name ::=
        COLUMNS {:
            RESULT = Axis.COLUMNS;
        :}
    |   ROWS {:
            RESULT = Axis.ROWS;
        :}
    |   PAGES {:
            RESULT = Axis.PAGES;
        :}
    |   SECTIONS {:
            RESULT = Axis.SECTIONS;
        :}
    |   CHAPTERS {:
            RESULT = Axis.CHAPTERS;
        :}
    ;

axis_number ::=
        NUMBER
    |   AXIS LPAREN NUMBER:n RPAREN {:
            RESULT = n;
        :}
    ;
//
// <dim_props> ::= [DIMENSION] PROPERTIES <property> [, <property>...]
dim_props ::=
        dimension_opt PROPERTIES property_list:pl {:
            RESULT = pl;
        :}
    ;
dimension_opt ::=
    /* empty */
    |   DIMENSION
    ;
property_list ::=
        property:p {:
            RESULT = new LinkedList();
            RESULT.add(p);
        :}
    |   property:p COMMA property_list:pl {:
            pl.add(0, p);
            RESULT = pl;
        :}
    ;
property ::=
        compound_id
    ;
//
// <cube_specification> ::= [<cube_name>] [, <cube_name>]
// jhyde: In this implementation, you must supply EXACTLY one cube.
cube_specification ::=
        cube_name;

//
// <filter_specification> ::= {<set> | <tuple>}
filter_specification ::=
        expression;
//
// <cell_props> ::= [CELL] PROPERTIES <cell_property> [, <cell_property>...]
cell_props ::=
        cell_opt PROPERTIES cell_property_list:p1 {:
            RESULT = p1;
        :}
    ;
cell_opt ::=
        /* empty */
    |   CELL
    ;
cell_property_list ::=
    cell_property:p {:
        RESULT = new LinkedList();
        RESULT.add(p);
    :}
    |   cell_property:p COMMA cell_property_list:p1 {:
        p1.add(0, p);
        RESULT = p1;
    :}
;

// <cell_property> ::= FORMAT_STRING
//                     | FORMATTED_VALUE
//                     | FORE_COLOR
//                     | BACK_COLOR
//                     | FONT_NAME
//                     | FONT_SIZE
//                     | FONT_FLAGS
//                     | CELL_ORDINAL
//                     | VALUE
cell_property ::= compound_id;

//
// <create_formula_statement> ::= CREATE [<scope>]<formula_specification>
//
// <drop_formula_statement> ::= <drop_member_statement>
//                            | <drop_set_statement>
//
// <drop_member_statement> ::= DROP MEMBER <member_name>
//                                      [, <member_name>...]
//
// <drop_set_statement> ::= DROP SET <set_name> [, <set_name>...]
//
// <scope> := GLOBAL | SESSION
//
// Leveling Rules for MDX Statement
//
// Support for <formula_specification> is optional. Consumers can check the
// value of the property MDPROP_MDX_FORMULAS to see whether a provider supports
// this feature.
//
//
// Support for <set> in <filter_specification> is optional. Consumers can check
// the value of the property MDPROP_MDX_SLICER to see whether a provider
// supports this feature.
//
//
// Support for more than one cube name in <cube_specification> is
// optional. Support for having no cube name in the FROM clause (that is, the
// cube is implicitly defined by the axis and filter dimensions) is also
// optional. Consumers can check the value of the property MDPROP_MDX_JOINCUBES
// to see whether a provider supports this feature.
//
//
// The axis names CHAPTERS and SECTIONS are optional. Consumers can check the
// value of the property MDPROP_AXES to see whether a provider supports this
// feature.
//
//
// Support for <index> > 2 in the AXIS(<index>) function is optional. Consumers
// can check the value of the property MDPROP_AXES to see whether a provider
// supports this feature.
//
//
// Support for <create_formula_statement> is optional. Consumers can check the
// value of the property MDPROP_MDX_FORMULAS to see whether a provider supports
// this feature.
//
//
// Support for <scope> of GLOBAL is optional. Consumers can check the value of
// the property MDPROP_MDX_FORMULAS to see whether a provider supports this
// feature.
//

// End DefaultMdxParser.cup
